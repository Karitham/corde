// GENERATED BY ./internal/cmd/gen-opt/ DO NOT EDIT.

package corde

import (
	"encoding/json"
	"github.com/Karitham/corde/components"
	"github.com/Karitham/corde/snowflake"
)

// StringOption represents a string option
type StringOption struct {
	Name         string
	Description  string
	Required     bool
	Choices      []components.Choice[any]
	ChannelTypes []components.ChannelType
	Autocomplete bool
}

// NewStringOption returns a new StringOption
func NewStringOption(name string, description string, required bool, choices ...components.Choice[string]) *StringOption {
	o := &StringOption{
		Name:         name,
		Description:  description,
		Required:     required,
		Choices:      []components.Choice[any]{},
		ChannelTypes: []components.ChannelType{},
	}

	for _, choice := range choices {
		o.Choices = append(
			o.Choices,
			components.Choice[any]{Name: choice.Name, Value: choice.Value},
		)
	}

	return o
}

// createOption returns the CreateOption of the type
func (o *StringOption) createOption() CreateOption {
	return CreateOption{
		Name:         o.Name,
		Description:  o.Description,
		Required:     o.Required,
		Choices:      o.Choices,
		ChannelTypes: o.ChannelTypes,
		Autocomplete: o.Autocomplete,
		Type:         components.OPTION_STRING,
	}
}

// ChanTypes sets the options channel types
func (o *StringOption) ChanTypes(typs ...components.ChannelType) *StringOption {
	o.ChannelTypes = append(o.ChannelTypes, typs...)
	return o
}

// MarshalJSON returns the JSON representation of the option
func (o *StringOption) MarshalJSON() ([]byte, error) {
	return json.Marshal(o.createOption())
}

// CanAutocomplete sets the option as autocomplete-able
func (o *StringOption) CanAutocomplete() *StringOption {
	o.Autocomplete = true
	return o
}

// IntOption represents a int option
type IntOption struct {
	Name         string
	Description  string
	Required     bool
	Choices      []components.Choice[any]
	ChannelTypes []components.ChannelType
	Autocomplete bool
}

// NewIntOption returns a new IntOption
func NewIntOption(name string, description string, required bool, choices ...components.Choice[int]) *IntOption {
	o := &IntOption{
		Name:         name,
		Description:  description,
		Required:     required,
		Choices:      []components.Choice[any]{},
		ChannelTypes: []components.ChannelType{},
	}

	for _, choice := range choices {
		o.Choices = append(
			o.Choices,
			components.Choice[any]{Name: choice.Name, Value: choice.Value},
		)
	}

	return o
}

// createOption returns the CreateOption of the type
func (o *IntOption) createOption() CreateOption {
	return CreateOption{
		Name:         o.Name,
		Description:  o.Description,
		Required:     o.Required,
		Choices:      o.Choices,
		ChannelTypes: o.ChannelTypes,
		Autocomplete: o.Autocomplete,
		Type:         components.OPTION_INTEGER,
	}
}

// ChanTypes sets the options channel types
func (o *IntOption) ChanTypes(typs ...components.ChannelType) *IntOption {
	o.ChannelTypes = append(o.ChannelTypes, typs...)
	return o
}

// MarshalJSON returns the JSON representation of the option
func (o *IntOption) MarshalJSON() ([]byte, error) {
	return json.Marshal(o.createOption())
}

// CanAutocomplete sets the option as autocomplete-able
func (o *IntOption) CanAutocomplete() *IntOption {
	o.Autocomplete = true
	return o
}

// NumberOption represents a float64 option
type NumberOption struct {
	Name         string
	Description  string
	Required     bool
	Choices      []components.Choice[any]
	ChannelTypes []components.ChannelType
	Autocomplete bool
}

// NewNumberOption returns a new NumberOption
func NewNumberOption(name string, description string, required bool, choices ...components.Choice[float64]) *NumberOption {
	o := &NumberOption{
		Name:         name,
		Description:  description,
		Required:     required,
		Choices:      []components.Choice[any]{},
		ChannelTypes: []components.ChannelType{},
	}

	for _, choice := range choices {
		o.Choices = append(
			o.Choices,
			components.Choice[any]{Name: choice.Name, Value: choice.Value},
		)
	}

	return o
}

// createOption returns the CreateOption of the type
func (o *NumberOption) createOption() CreateOption {
	return CreateOption{
		Name:         o.Name,
		Description:  o.Description,
		Required:     o.Required,
		Choices:      o.Choices,
		ChannelTypes: o.ChannelTypes,
		Autocomplete: o.Autocomplete,
		Type:         components.OPTION_NUMBER,
	}
}

// ChanTypes sets the options channel types
func (o *NumberOption) ChanTypes(typs ...components.ChannelType) *NumberOption {
	o.ChannelTypes = append(o.ChannelTypes, typs...)
	return o
}

// MarshalJSON returns the JSON representation of the option
func (o *NumberOption) MarshalJSON() ([]byte, error) {
	return json.Marshal(o.createOption())
}

// CanAutocomplete sets the option as autocomplete-able
func (o *NumberOption) CanAutocomplete() *NumberOption {
	o.Autocomplete = true
	return o
}

// BoolOption represents a bool option
type BoolOption struct {
	Name         string
	Description  string
	Required     bool
	Choices      []components.Choice[any]
	ChannelTypes []components.ChannelType
	Autocomplete bool
}

// NewBoolOption returns a new BoolOption
func NewBoolOption(name string, description string, required bool, choices ...components.Choice[bool]) *BoolOption {
	o := &BoolOption{
		Name:         name,
		Description:  description,
		Required:     required,
		Choices:      []components.Choice[any]{},
		ChannelTypes: []components.ChannelType{},
	}

	for _, choice := range choices {
		o.Choices = append(
			o.Choices,
			components.Choice[any]{Name: choice.Name, Value: choice.Value},
		)
	}

	return o
}

// createOption returns the CreateOption of the type
func (o *BoolOption) createOption() CreateOption {
	return CreateOption{
		Name:         o.Name,
		Description:  o.Description,
		Required:     o.Required,
		Choices:      o.Choices,
		ChannelTypes: o.ChannelTypes,
		Autocomplete: o.Autocomplete,
		Type:         components.OPTION_BOOLEAN,
	}
}

// ChanTypes sets the options channel types
func (o *BoolOption) ChanTypes(typs ...components.ChannelType) *BoolOption {
	o.ChannelTypes = append(o.ChannelTypes, typs...)
	return o
}

// MarshalJSON returns the JSON representation of the option
func (o *BoolOption) MarshalJSON() ([]byte, error) {
	return json.Marshal(o.createOption())
}

// UserOption represents a snowflake.Snowflake option
type UserOption struct {
	Name         string
	Description  string
	Required     bool
	Choices      []components.Choice[any]
	ChannelTypes []components.ChannelType
	Autocomplete bool
}

// NewUserOption returns a new UserOption
func NewUserOption(name string, description string, required bool, choices ...components.Choice[snowflake.Snowflake]) *UserOption {
	o := &UserOption{
		Name:         name,
		Description:  description,
		Required:     required,
		Choices:      []components.Choice[any]{},
		ChannelTypes: []components.ChannelType{},
	}

	for _, choice := range choices {
		o.Choices = append(
			o.Choices,
			components.Choice[any]{Name: choice.Name, Value: choice.Value},
		)
	}

	return o
}

// createOption returns the CreateOption of the type
func (o *UserOption) createOption() CreateOption {
	return CreateOption{
		Name:         o.Name,
		Description:  o.Description,
		Required:     o.Required,
		Choices:      o.Choices,
		ChannelTypes: o.ChannelTypes,
		Autocomplete: o.Autocomplete,
		Type:         components.OPTION_USER,
	}
}

// ChanTypes sets the options channel types
func (o *UserOption) ChanTypes(typs ...components.ChannelType) *UserOption {
	o.ChannelTypes = append(o.ChannelTypes, typs...)
	return o
}

// MarshalJSON returns the JSON representation of the option
func (o *UserOption) MarshalJSON() ([]byte, error) {
	return json.Marshal(o.createOption())
}

// ChannelOption represents a snowflake.Snowflake option
type ChannelOption struct {
	Name         string
	Description  string
	Required     bool
	Choices      []components.Choice[any]
	ChannelTypes []components.ChannelType
	Autocomplete bool
}

// NewChannelOption returns a new ChannelOption
func NewChannelOption(name string, description string, required bool, choices ...components.Choice[snowflake.Snowflake]) *ChannelOption {
	o := &ChannelOption{
		Name:         name,
		Description:  description,
		Required:     required,
		Choices:      []components.Choice[any]{},
		ChannelTypes: []components.ChannelType{},
	}

	for _, choice := range choices {
		o.Choices = append(
			o.Choices,
			components.Choice[any]{Name: choice.Name, Value: choice.Value},
		)
	}

	return o
}

// createOption returns the CreateOption of the type
func (o *ChannelOption) createOption() CreateOption {
	return CreateOption{
		Name:         o.Name,
		Description:  o.Description,
		Required:     o.Required,
		Choices:      o.Choices,
		ChannelTypes: o.ChannelTypes,
		Autocomplete: o.Autocomplete,
		Type:         components.OPTION_CHANNEL,
	}
}

// ChanTypes sets the options channel types
func (o *ChannelOption) ChanTypes(typs ...components.ChannelType) *ChannelOption {
	o.ChannelTypes = append(o.ChannelTypes, typs...)
	return o
}

// MarshalJSON returns the JSON representation of the option
func (o *ChannelOption) MarshalJSON() ([]byte, error) {
	return json.Marshal(o.createOption())
}

// RoleOption represents a snowflake.Snowflake option
type RoleOption struct {
	Name         string
	Description  string
	Required     bool
	Choices      []components.Choice[any]
	ChannelTypes []components.ChannelType
	Autocomplete bool
}

// NewRoleOption returns a new RoleOption
func NewRoleOption(name string, description string, required bool, choices ...components.Choice[snowflake.Snowflake]) *RoleOption {
	o := &RoleOption{
		Name:         name,
		Description:  description,
		Required:     required,
		Choices:      []components.Choice[any]{},
		ChannelTypes: []components.ChannelType{},
	}

	for _, choice := range choices {
		o.Choices = append(
			o.Choices,
			components.Choice[any]{Name: choice.Name, Value: choice.Value},
		)
	}

	return o
}

// createOption returns the CreateOption of the type
func (o *RoleOption) createOption() CreateOption {
	return CreateOption{
		Name:         o.Name,
		Description:  o.Description,
		Required:     o.Required,
		Choices:      o.Choices,
		ChannelTypes: o.ChannelTypes,
		Autocomplete: o.Autocomplete,
		Type:         components.OPTION_ROLE,
	}
}

// ChanTypes sets the options channel types
func (o *RoleOption) ChanTypes(typs ...components.ChannelType) *RoleOption {
	o.ChannelTypes = append(o.ChannelTypes, typs...)
	return o
}

// MarshalJSON returns the JSON representation of the option
func (o *RoleOption) MarshalJSON() ([]byte, error) {
	return json.Marshal(o.createOption())
}

// MentionableOption represents a snowflake.Snowflake option
type MentionableOption struct {
	Name         string
	Description  string
	Required     bool
	Choices      []components.Choice[any]
	ChannelTypes []components.ChannelType
	Autocomplete bool
}

// NewMentionableOption returns a new MentionableOption
func NewMentionableOption(name string, description string, required bool, choices ...components.Choice[snowflake.Snowflake]) *MentionableOption {
	o := &MentionableOption{
		Name:         name,
		Description:  description,
		Required:     required,
		Choices:      []components.Choice[any]{},
		ChannelTypes: []components.ChannelType{},
	}

	for _, choice := range choices {
		o.Choices = append(
			o.Choices,
			components.Choice[any]{Name: choice.Name, Value: choice.Value},
		)
	}

	return o
}

// createOption returns the CreateOption of the type
func (o *MentionableOption) createOption() CreateOption {
	return CreateOption{
		Name:         o.Name,
		Description:  o.Description,
		Required:     o.Required,
		Choices:      o.Choices,
		ChannelTypes: o.ChannelTypes,
		Autocomplete: o.Autocomplete,
		Type:         components.OPTION_MENTIONABLE,
	}
}

// ChanTypes sets the options channel types
func (o *MentionableOption) ChanTypes(typs ...components.ChannelType) *MentionableOption {
	o.ChannelTypes = append(o.ChannelTypes, typs...)
	return o
}

// MarshalJSON returns the JSON representation of the option
func (o *MentionableOption) MarshalJSON() ([]byte, error) {
	return json.Marshal(o.createOption())
}
